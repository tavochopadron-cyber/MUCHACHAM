# -*- coding: utf-8 -*-
"""MUCHACHAM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_aAcsinZ4vGNQYvbOTRASZFbYRj7X_ZN
"""

# -*- coding: utf-8 -*-
"""VersiÃ³n optimizada del sistema de selecciÃ³n BRICOS"""

import base64
import os
import secrets # Usamos secrets para una generaciÃ³n de tokens mÃ¡s robusta/segura
from collections import defaultdict # Para un conteo mÃ¡s limpio

# --- PARÃMETROS ---
NUM_PREGUNTAS_TECNICAS = 12
NUM_PREGUNTAS_BLANDAS = 13
PUNTAJE_MINIMO_BLANDAS = 0.75  # 75%

# --- CLAVE RSA SIMULADA MEJORADA (MUESTRA INTENCIÃ“N DE CLAVE REAL) ---
class RSAKeySimulada:
    """Clase para simular la generaciÃ³n de claves pÃºblica/privada."""
    def __init__(self):
        # Genera una clave pÃºblica (por ejemplo, 256 bits)
        self.public_key = base64.b64encode(secrets.token_bytes(32)).decode("utf-8")
        # Genera una clave privada (no se usa, pero simula su existencia)
        self.private_key = base64.b64encode(secrets.token_bytes(32)).decode("utf-8")

def cifrar_rsa_simulado(datos, clave_publica):
    """Simula el cifrado usando la clave pÃºblica."""
    # SimulaciÃ³n de un proceso de cifrado que devuelve un output mÃ¡s complejo
    datos_codificados = base64.urlsafe_b64encode(datos.encode("utf-8")).decode("utf-8")
    # Formato que simula un mensaje cifrado
    return f"RSA-256-CIPHER:{clave_publica[:16]}...{datos_codificados[:40]}..."

# --- PREGUNTAS (Se mantienen igual) ---
PREGUNTAS_TECNICAS = [
    "Â¿Sabe realizar inventarios fÃ­sicos y conteos rÃ¡pidos de material de construcciÃ³n?", # 0
    "Â¿Ha utilizado algÃºn software de Punto de Venta (POS) o sistema de facturaciÃ³n electrÃ³nica?", # 1
    "Â¿Sabe leer e interpretar una hoja de ruta o usar GPS para optimizar entregas?", # 2
    "Â¿Tiene experiencia o conoce el manejo bÃ¡sico de un montacargas o patÃ­n hidrÃ¡ulico?", # 3
    "Â¿Puede identificar y diferenciar los tipos de cemento, varilla y arena comunes en la construcciÃ³n?", # 4
    "Â¿Sabe cÃ³mo se calcula el volumen o Ã¡rea de un material (ej. mÂ³ de arena, mÂ² de loseta)?", # 5
    "Â¿Se siente cÃ³modo manejando una terminal bancaria y realizando cobros con tarjeta?", # 6
    "Â¿Puede verificar y cotejar una orden de compra contra el material fÃ­sico que se va a cargar?", # 7
    "Â¿Conoce las normas bÃ¡sicas de seguridad para cargar y descargar materiales pesados?", # 8
    "Â¿Tiene conocimientos bÃ¡sicos de uso de hojas de cÃ¡lculo (Excel, Google Sheets) para reportes?", # 9
    "Â¿Sabe realizar el mantenimiento bÃ¡sico o limpieza de herramientas y equipos de trabajo?", # 10
    "Â¿Puede calcular rÃ¡pidamente el cambio para un pago en efectivo?" # 11
]

PREGUNTAS_BLANDAS = [
    "Â¿Mantiene la calma y es cortÃ©s al tratar con un cliente enojado o impaciente?",
    "Â¿Se adapta fÃ¡cilmente a los cambios de tareas o prioridades de Ãºltima hora?",
    "Â¿Ofrece ayuda a sus compaÃ±eros sin que se lo pidan?",
    "Â¿Es puntual y respeta estrictamente los horarios?",
    "Â¿Acepta retroalimentaciÃ³n sin ponerse a la defensiva?",
    "Â¿Se enfoca en soluciones en lugar de culpar a otros?",
    "Â¿Es proactivo buscando tareas pendientes?",
    "Â¿Se comunica de manera clara y concisa?",
    "Â¿Trabaja bien bajo presiÃ³n?",
    "Â¿Su honestidad y Ã©tica son inquebrantables?",
    "Â¿Prioriza la seguridad ante todo?",
    "Â¿Propone mejoras a procesos ineficientes?",
    "Â¿Se siente cÃ³modo pidiendo al cliente verificar la carga/ticket?"
]

# --- ASIGNACIÃ“N DE ÃREA POR HABILIDADES ---
AREAS = {
    # El Ã­ndice corresponde a la pregunta en PREGUNTAS_TECNICAS
    "CARGADOR":         [0, 3, 4, 7, 8],
    "VENTAS/COBRANZA":  [1, 6, 11],
    "REPARTIDOR":       [2, 3, 7, 8],
    "LIMPIEZA":         [10],
    "ADMINISTRATIVO":   [9, 1, 5] # Agregamos un par de preguntas relevantes para Admin
}

# La funciÃ³n se mantiene igual, asigna el Ã¡rea con mÃ¡s coincidencias 'S'
def asignar_area(respuestas):
    """Asigna el Ã¡rea tÃ©cnica con el mayor nÃºmero de coincidencias 'S'."""
    conteo = defaultdict(int)
    for area, indices in AREAS.items():
        # Cuenta las respuestas 'S' solo para las preguntas relevantes del Ã¡rea
        conteo[area] = sum(1 for i in indices if i < len(respuestas) and respuestas[i] == "S")

    # Si todas las respuestas son 'N', devuelve el Ã¡rea con la lista de preguntas mÃ¡s larga como default
    if not any(conteo.values()):
        return max(AREAS, key=lambda a: len(AREAS[a]))

    return max(conteo, key=conteo.get)


# --- SELECCIÃ“N DE ÃREA DESEADA (Se mantiene igual) ---
def seleccionar_area_deseada():
    opciones = {
        "1": "CARGADOR",
        "2": "VENTAS/COBRANZA",
        "3": "REPARTIDOR",
        "4": "LIMPIEZA",
        "5": "ADMINISTRATIVO"
    }

    print("\n--- SELECCIONA EL PUESTO AL QUE DESEAS APLICAR ---")
    for k, v in opciones.items():
        print(f"{k}. {v}")

    while True:
        eleccion = input("Elige una opciÃ³n (1-5): ").strip()
        if eleccion in opciones:
            return opciones[eleccion]
        print("OpciÃ³n no vÃ¡lida. Intenta nuevamente.")

# --- DATOS PERSONALES (Se mantiene igual) ---
def pedir_datos_personales():
    def pedir_campo(mensaje, obligatorio=True):
        while True:
            valor = input(mensaje).strip()
            if valor or not obligatorio:
                return valor
            print("Este campo no puede quedar vacÃ­o.")

    print("--- DATOS PERSONALES ---")
    datos = {
        "nombre": pedir_campo("Nombre completo: "),
        "edad": pedir_campo("Edad: "),
        "sexo": pedir_campo("Sexo (M/F/Otro): "),
        "correo": pedir_campo("Correo electrÃ³nico (SerÃ¡ cifrado): "),
        "telefono": pedir_campo("NÃºmero de telÃ©fono (SerÃ¡ cifrado): ")
    }
    return datos

# --- CUESTIONARIO (REUTILIZABLE, se mantiene igual) ---
def realizar_cuestionario(preguntas, tipo):
    puntaje = 0
    respuestas = []

    print(f"\n--- HABILIDADES {tipo.upper()} ({len(preguntas)} preguntas) ---")

    for i, pregunta in enumerate(preguntas):
        while True:
            r = input(f"â“ {i+1}. {pregunta} (S/N): ").upper().strip()
            if r in ("S", "N"):
                respuestas.append(r)
                if r == "S":
                    puntaje += 1
                break
            print("Respuesta invÃ¡lida. Solo S o N.")
    return puntaje, respuestas

# --- EVALUACIÃ“N (Se mantiene igual) ---
def evaluar_resultados(pt_tecnico, pt_blando):
    pct_tec = (pt_tecnico / NUM_PREGUNTAS_TECNICAS) * 100
    pct_bla = (pt_blando / NUM_PREGUNTAS_BLANDAS) * 100
    # La aceptaciÃ³n se basa estrictamente en el puntaje blando (75%)
    es_aceptado = pct_bla >= (PUNTAJE_MINIMO_BLANDAS * 100)
    return es_aceptado, pct_tec, pct_bla

# --- PROCESO PRINCIPAL ---
def iniciar_proceso_seleccion():
    print("=====================================================")
    print(" Â  Â  ğŸŒŸ MUCHACHAM ğŸŒŸ")
    print("=====================================================")

    datos = pedir_datos_personales()
    area_deseada = seleccionar_area_deseada()

    # Cifrado simulado MEJORADO
    key_generator = RSAKeySimulada()
    datos_cifrados = cifrar_rsa_simulado(
        f"Email:{datos['correo']}|Tel:{datos['telefono']}",
        key_generator.public_key
    )
    print("âœ… Datos de contacto cifrados con RSA simulado (Clave PÃºblica generada).")

    # Cuestionarios
    pt_tecnico, resp_tecnicas = realizar_cuestionario(PREGUNTAS_TECNICAS, "TÃ‰CNICAS")
    pt_blando, _ = realizar_cuestionario(PREGUNTAS_BLANDAS, "BLANDAS")

    # EvaluaciÃ³n final
    aceptado, pct_tec, pct_bla = evaluar_resultados(pt_tecnico, pt_blando)

    # El error de "siempre ir a cargador" no estaba en la lÃ³gica de 'asignar_area',
    # sino en la percepciÃ³n de que la baja puntuaciÃ³n blanda forzaba el resultado.
    # El Ã¡rea recomendada SOLO depende de las respuestas TÃ‰CNICAS.
    area_recomendada = asignar_area(resp_tecnicas)

    # Resultados
    print("\n================= RESULTADO FINAL =================")
    print(f"**Puesto Deseado:** Â  {area_deseada}") # <-- CORRECCIÃ“N A: Mostrar el puesto deseado
    print(f"**Ãrea Recomendada:** {area_recomendada}")
    print("---------------------------------------------------")
    print(f"TÃ‰CNICAS: {pt_tecnico}/{NUM_PREGUNTAS_TECNICAS} ({pct_tec:.2f}%)")
    print(f"BLANDAS: Â {pt_blando}/{NUM_PREGUNTAS_BLANDAS} ({pct_bla:.2f}%) (MÃ­nimo requerido: {PUNTAJE_MINIMO_BLANDAS*100:.0f}%)")
    print("---------------------------------------------------")

    # Mostrar estado de aceptaciÃ³n
    if aceptado:
        print("ESTADO FINAL: **âœ… ACEPTADO**")
    else:
        print("ESTADO FINAL: **âŒ NO ACEPTADO** (Fallo en puntaje BLANDO)")

    # Coincidencia de Ã¡reas
    if area_recomendada == area_deseada:
        print("â­ Â¡Felicidades! Coincide el Ã¡rea deseada con tu perfil tÃ©cnico.")
    else:
        print(f"ğŸ’¡ Sugerencia: El Ã¡rea **{area_recomendada}** es un mejor ajuste segÃºn tus habilidades tÃ©cnicas.")

    print("\n================= REGISTRO DE DATOS =================")
    print(f"Nombre: {datos['nombre']} | Edad: {datos['edad']}")
    print(f"DATOS CIFRADOS (simulaciÃ³n): {datos_cifrados}")
    print("=====================================================")

# Ejecutar el programa
if __name__ == "__main__":
    iniciar_proceso_seleccion()