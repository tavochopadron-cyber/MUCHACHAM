# -*- coding: utf-8 -*-
"""MDB.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1peZQ4dj1pGnUsTYXF-cv0iaF2JdyExEb
"""

# -*- coding: utf-8 -*-

import base64
import secrets
from collections import defaultdict
from pymongo import MongoClient

# ================================
# 游댯  CONEXI칍N A MONGODB
# ================================
MONGO_URI = "mongodb+srv://tavo_user:1234567#@cluster0.cjx2xfb.mongodb.net/?appName=Cluster0"
client = MongoClient(MONGO_URI)
db = client["muchacham_db"]
coleccion = db["candidatos"]

# ================================
#  PAR츼METROS
# ================================
NUM_PREGUNTAS_TECNICAS = 12
NUM_PREGUNTAS_BLANDAS = 13
PUNTAJE_MINIMO_BLANDAS = 0.60

# ================================
# CIFRADO RSA (BASE 64)
# ================================
from cryptography.hazmat.primitives.asymmetric 
import rsa, padding
from cryptography.hazmat.primitives
import serialization, hashes

private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
public_key = private_key.public_key()

public_pem = public_key.public_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PublicFormat.SubjectPublicKeyInfo
)

def cifrar_rsa_real(datos, public_key):
    encrypted = public_key.encrypt(
        datos.encode("utf-8"),
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
    return base64.b64encode(encrypted).decode("utf-8")

# ================================
# 游댯  PREGUNTAS T칄CNICAS
# ================================
PREGUNTAS_TECNICAS = [
    "쯉abe realizar inventarios f칤sicos y conteos r치pidos de material de construcci칩n?",
    "쮿a utilizado alg칰n software de Punto de Venta (POS) o sistema de facturaci칩n electr칩nica?",
    "쯉abe leer e interpretar una hoja de ruta o usar GPS para optimizar entregas?",
    "쯊iene experiencia o conoce el manejo b치sico de un montacargas o pat칤n hidr치ulico?",
    "쯇uede identificar y diferenciar los tipos de cemento, varilla y arena comunes en la construcci칩n?",
    "쯉abe c칩mo se calcula el volumen o 치rea de un material (ej. m췁 de arena, m de loseta)?",
    "쯉e siente c칩modo manejando una terminal bancaria y realizando cobros con tarjeta?",
    "쯇uede verificar y cotejar una orden de compra contra el material f칤sico que se va a cargar?",
    "쮺onoce las normas b치sicas de seguridad para cargar y descargar materiales pesados?",
    "쯊iene conocimientos b치sicos de uso de hojas de c치lculo (Excel, Google Sheets) para reportes?",
    "쯉abe realizar el mantenimiento b치sico o limpieza de herramientas y equipos de trabajo?",
    "쯇uede calcular r치pidamente el cambio para un pago en efectivo?"
]

PREGUNTAS_BLANDAS = [
    "쯄antiene la calma y es cort칠s al tratar con un cliente enojado o impaciente?",
    "쯉e adapta f치cilmente a los cambios de tareas o prioridades de 칰ltima hora?",
    "쯆frece ayuda a sus compa침eros sin que se lo pidan?",
    "쮼s puntual y respeta estrictamente los horarios?",
    "쮸cepta retroalimentaci칩n sin ponerse a la defensiva?",
    "쯉e enfoca en soluciones en lugar de culpar a otros?",
    "쮼s proactivo buscando tareas pendientes?",
    "쯉e comunica de manera clara y concisa?",
    "쯊rabaja bien bajo presi칩n?",
    "쯉u honestidad y 칠tica son inquebrantables?",
    "쯇rioriza la seguridad ante todo?",
    "쯇ropone mejoras a procesos ineficientes?",
    "쯉e siente c칩modo pidiendo al cliente verificar la carga/ticket?"
]

# ================================
#   츼REAS
# ================================
AREAS = {
    "CARGADOR":         [0, 3, 4, 7, 8],
    "VENTAS/COBRANZA":  [1, 6, 11],
    "REPARTIDOR":       [2, 3, 7, 8],
    "LIMPIEZA":         [10],
    "ADMINISTRATIVO":   [9, 1, 5]
}

def asignar_area(respuestas):
    conteo = defaultdict(int)
    for area, indices in AREAS.items():
        conteo[area] = sum(1 for i in indices if respuestas[i] == "S칤")

    if not any(conteo.values()):
        return max(AREAS, key=lambda a: len(AREAS[a]))

    return max(conteo, key=conteo.get)

# ================================
#  SELECCI칍N DE 츼REA DESEADA
# ================================
def seleccionar_area_deseada():
    opciones = {
        "1": "CARGADOR",
        "2": "VENTAS/COBRANZA",
        "3": "REPARTIDOR",
        "4": "LIMPIEZA",
        "5": "ADMINISTRATIVO"
    }

    print("\n--- PUESTO AL QUE DESEAS APLICAR ---")
    for k, v in opciones.items():
        print(f"{k}. {v}")

    while True:
        eleccion = input("Elige una opci칩n (1-5): ").strip()
        if eleccion in opciones:
            return opciones[eleccion]
        print("Opci칩n no v치lida.")

# ================================
#   DATOS PERSONALES
# ================================
def pedir_datos_personales():
    def pedir(m):
        while True:
            x = input(m).strip()
            if x:
                return x
            print("No puede quedar vac칤o.")

    print("\n--- DATOS PERSONALES ---")
    return {
        "nombre": pedir("Nombre completo: "),
        "edad": pedir("Edad: "),
        "sexo": pedir("Sexo (M/F/Otro): "),
        "correo": pedir("Correo electr칩nico (se cifrar치): "),
        "telefono": pedir("N칰mero de tel칠fono (se cifrar치): ")
    }

# ================================
#   CUESTIONARIO (si/no)
# ================================
def realizar_cuestionario(preguntas, tipo):
    puntaje = 0
    respuestas = []

    print(f"\n--- HABILIDADES {tipo.upper()} ---")
    for i, p in enumerate(preguntas):
        while True:
            r = input(f"{i+1}. {p} (S/N): ").upper().strip()
            if r in ("S", "N"):
                respuestas.append("S칤" if r == "S" else "No")
                if r == "S":
                    puntaje += 1
                break
            print("Respuesta inv치lida.")
    return puntaje, respuestas

# ================================
#  EVALUACI칍N
# ================================
def evaluar(pt_tecnico, pt_blando):
    return (
        (pt_blando / NUM_PREGUNTAS_BLANDAS) >= PUNTAJE_MINIMO_BLANDAS,
        (pt_tecnico / NUM_PREGUNTAS_TECNICAS) * 100,
        (pt_blando / NUM_PREGUNTAS_BLANDAS) * 100
    )

# ================================
#   PROCESO PRINCIPAL
# ================================
def iniciar_proceso_seleccion():
    print("\n========================================")
    print(" SISTEMA DE SELECCI칍N MUCHACHAM ")
    print("========================================")

    datos = pedir_datos_personales()
    area_deseada = seleccionar_area_deseada()

    key = RSAKeySimulada()
    datos_cifrados = cifrar_rsa_simulado(
        f"Email:{datos['correo']}|Tel:{datos['telefono']}",
        key.public_key
    )

    pt_tecnico, resp_tecnicas = realizar_cuestionario(PREGUNTAS_TECNICAS, "T칄CNICAS")
    pt_blando, resp_blandas = realizar_cuestionario(PREGUNTAS_BLANDAS, "BLANDAS")

    aceptado, pct_tec, pct_bla = evaluar(pt_tecnico, pt_blando)
    area_recomendada = asignar_area(resp_tecnicas)

    # =============================
    # GUARDAR EN MONGODB
    # =============================
    registro = {
        "nombre": datos["nombre"],
        "edad": datos["edad"],
        "sexo": datos["sexo"],
        "correo_cifrado": datos_cifrados,
        "puesto_deseado": area_deseada,
        "area_recomendada": area_recomendada,
        "puntaje_tecnico": pt_tecnico,
        "puntaje_blando": pt_blando,
        "porcentaje_tecnico": pct_tec,
        "porcentaje_blando": pct_bla,
        "aceptado": aceptado,
        "respuestas_tecnicas": resp_tecnicas,
        "respuestas_blandas": resp_blandas
    }

    coleccion.insert_one(registro)
    print("\n游늷 Datos guardados correctamente en MongoDB.\n")

    print("=========== RESULTADO FINAL ===========")
    print(f"Puesto deseado:     {area_deseada}")
    print(f"츼rea recomendada:   {area_recomendada}")
    print(f"T칠cnicas: {pct_tec:.2f}% | Blandas: {pct_bla:.2f}%")
    print("Estado:", "ACEPTADO " if aceptado else "NO ACEPTADO ")
    print("========================================")

# Ejecutar
if __name__ == "__main__":
    iniciar_proceso_seleccion()
